require('./setup')()
const fs = require('fs')

describe('install', function describeInstall() {
  const install = require('../lib/install')

  it('warns when the target is not a git project', sinon.test(function test() {
    fsStub({})
    const warn = this.stub(console, 'warn')
    install()
    expect(warn).to.have.been.calledWithMatch(/this does not seem to be a git project/i)
  }))

  it('creates hooks directory', () => {
    fsStub({'.git': {}})
    install()
    expect(fs.existsSync('.git/hooks')).to.be.true
  })

  it('creates a package.json', () => {
    fsStub({'.git/hooks': {}})
    install()

    const hooks = fs.readdirSync('.git/hooks')
    const packageContent = require('../lib/package.template').content
    expect(hooks).to.include('package.json')
    expect(JSON.parse(fs.readFileSync('.git/hooks/package.json', 'UTF-8'))).to.deep.equal(packageContent)
  })

  it('creates hook files', () => {
    fsStub({'.git/hooks': {}})
    install()

    const hooks = fs.readdirSync('.git/hooks')
    const hookContent = require('../lib/hook.template').content
    function expectHook(hook, filename, permission) {
      expect(hooks).to.include(hook)
      expect(fs.readFileSync(filename, 'UTF-8')).to.equal(hookContent)
      expect(fileMode(filename)).to.equal(permission)
    }

    // expectHook(<hook>, <filename>, <permission>)
    expectHook('applypatch-msg', '.git/hooks/applypatch-msg', '755')
    expectHook('pre-applypatch', '.git/hooks/pre-applypatch', '755')
    expectHook('post-applypatch', '.git/hooks/post-applypatch', '755')
    expectHook('pre-commit', '.git/hooks/pre-commit', '755')
    expectHook('prepare-commit-msg', '.git/hooks/prepare-commit-msg', '755')
    expectHook('commit-msg', '.git/hooks/commit-msg', '755')
    expectHook('post-commit', '.git/hooks/post-commit', '755')
    expectHook('pre-rebase', '.git/hooks/pre-rebase', '755')
    expectHook('post-checkout', '.git/hooks/post-checkout', '755')
    expectHook('post-merge', '.git/hooks/post-merge', '755')
    expectHook('pre-push', '.git/hooks/pre-push', '755')
    expectHook('pre-receive', '.git/hooks/pre-receive', '755')
    expectHook('update', '.git/hooks/update', '755')
    expectHook('post-receive', '.git/hooks/post-receive', '755')
    expectHook('post-update', '.git/hooks/post-update', '755')
    expectHook('pre-auto-gc', '.git/hooks/pre-auto-gc', '755')
    expectHook('post-rewrite', '.git/hooks/post-rewrite', '755')
  })

  describe('backs up an existing package.json', () => {

    const existingGHookPackage = '// Generated by ghooks. Do not edit this file.'
    const existingUserPackage = '# existing content'

    it('does not keep a copy of an existing GHook package.json', () => {
      fsStub({'.git/hooks': {
        'package.json': existingGHookPackage,
      }})

      install()
      const files = fs.readdirSync('.git/hooks')

      expect(files).to.not.include('package.json.bkp')
      expect(files).to.include('package.json')
    })

    it('backs up an existing user package.json', () => {
      fsStub({'.git/hooks': {
        'package.json': existingUserPackage,
      }})

      install()
      const files = fs.readdirSync('.git/hooks')

      expect(files).to.include('package.json.bkp')
      expect(files).to.include('package.json')
      expect(fs.readFileSync('.git/hooks/package.json.bkp', 'UTF-8')).to.equal(existingUserPackage)
    })

  })

  describe('backing up existing hooks', () => {

    const existingGHook = '// Generated by ghooks. Do not edit this file.'
    const existingUserHook = '# existing content'

    beforeEach(() => {
      fsStub({'.git/hooks': {
        'pre-commit': existingGHook,
        'pre-push': existingUserHook,
      }})

      install()
      this.files = fs.readdirSync('.git/hooks')
    })

    it('does not keep a copy of an existing GHook', () => {
      expect(this.files).to.not.include('pre-commit.bkp')
      expect(this.files).to.include('pre-commit')
    })

    it('backs up an existing user hook', () => {
      expect(this.files).to.include('pre-push')
      expect(this.files).to.include('pre-push.bkp')
      expect(fs.readFileSync('.git/hooks/pre-push.bkp', 'UTF-8')).to.equal(existingUserHook)
    })

  })

})

describe('install using worktree / as a submodule', function describeInstall() {
  const install = require('../lib/install')

  it('warns when no gitdir specified for worktree / submodule', sinon.test(function test() {
    fsStub({'.git': ''})
    const warn = this.stub(console, 'warn')
    install()
    expect(warn).to.have.been.calledWithMatch(/this does not seem to be a git project/i)
  }))

  it('creates hooks directory using gitdir', () => {
    fsStub({
      '.git': 'gitdir: ../../a/path/somewhere/else',
      '../../a/path/somewhere/else': {},
    })
    install()
    expect(fs.existsSync('../../a/path/somewhere/else/hooks')).to.be.true
  })

})

describe('install (ensure 100% code coverage)', function describeInstall() {
  const install = require('proxyquire')('../lib/install', {
    fs: {
      statSync() {
        // to provoke the case where a '.git' entry on the filesystem
        // is neither a directory nor a file
        return {isDirectory: () => false, isFile: () => false}
      },
    },
  })

  it('warns when no gitdir specified for worktree / submodule', sinon.test(function test() {
    const warn = this.stub(console, 'warn')
    fsStub({'.git': ''})
    install()
    expect(warn).to.have.been.calledWithMatch(/this does not seem to be a git project/i)
  }))

})

function fileMode(file) {
  const allOn = 4095 // == 07777 (octal)
  return (fs.statSync(file).mode & allOn) // eslint-disable-line no-bitwise
    .toString(8)
}
